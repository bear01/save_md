



### 阿里

1. **Hashset中的contains函数，equals实现**

   hashset是一个set集合，集合特点：元素无序、唯一

   hashset 通过hashcode 来区分对象是否唯一

   HashSet的对象中着一个集合中对象的hashcode的list，每次执行set.add(obj)的时候，都会取出obj的hashcode与其内部的list进行比较，如果没有与之相等的，就加进set里去，同时把那个obj的hashcode加到list里面去；如果有相等的，就再调用obj的equals方法与各个对象进行比较，如果没有相等的，就加入到set里面去，如果还有相等的，就不执行加入操作。

其实相当于执行了一次contains方法，根据contains方法的返回值决定是否真的add

2. **java代码输出hello world 字符串整个过程**

* 编译: javac tedt.java,生成java的字节码文件：Test.class

* 执行class文件
* 申请内存栈
* 输出内容

3. **tcp四次握手timewait的目的 ？**

> (1) 是为了保证最后一个ack报文能到达B(服务器)。这个ACK报文有可能丢失，因而使得处在LAST_ACK状态得不到对已发送的FIN+ACK报文的确认，B会超时重传这个FIN+ACk ,而A就能在这TIME_WAIT时间（2MSL）里收到这个重传的报文，A就可以重传一次确认，如果没有这个TIME_WAIT， 那B重传的FIN_ACK，可A早就走了，自然不会再重发确认，这样B就无法按照正常步骤进入CLOSE 状态。
>
> (2) 防止“已失效的报文连接请求”。A在TIME_WAIT中，经过这2MSL的时间，就可以使本链接持续的时间内产生的所有连接消失，这样就可以使下一个新的连接中不会出现这样旧的连接请求报文段

4. **二分查找和二叉树查找区别？**

>二分查找： 折半查找，比较次数少，查找速度快，但表必须有序，删除插入困难 时间复杂度log(n)
>
>二叉树查找： 左子树所有节点均小于根节点；右子树所有节点均大于根节点；左右子树也分别是二叉树。插入和删除比较快 
>
>时间复杂度相同：log(n)
>
>
>
>顺序存储和链式存储的概念
>（1）从空间性能，顺序存储会对空间资源做到百分之百的利用，而链式存储对对空间的利用不是百分之百，因为存储了指针，不是真正的数据
>（2）从时间性能上来讲读取速度的话顺序存储更优，插入和删除操作链式存储更优，链式存储只需要移动指针，不需要移动元素。

5. **hashmap底层 ，hash查找，get方法，loadfacter作用，影响hash查找效率的因素？**

>jdk1.7：数组（位桶）+链表
>
>jdk1.8:	数组（位桶）+链表+红黑树
>
>![这里写图片描述](https://img-blog.csdn.net/20170309184031044?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWluYmluZ3FpdQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
>
>
>
>为什么加红黑树：链表的作用是为了解决hash冲突。，同一hash值的链表都 存储在一个链表中，当桶中元素较多，相同的hash值也越多，通过数组+链表的方式查询效率较低，加入红黑树，当链表长度超过**阈值8**，就将链表转换成红黑树，减少查询时间。
>
>loadfacter(加载因子)：**默认0.75**
>
>当链表数组的容量超过初始容量的0.75时，再散列将链表数组**扩大2倍**，把原链表数组的搬移到新的数组中。
>
>为什么需要使用加载因子，为什么需要扩容呢？因为如果填充比很大，说明利用的空间很多，如果一直不进行扩容的话，链表就会越来越长，这样查找的效率很低，扩容之后，将原来链表数组的每一个链表分成奇偶两个子链表分别挂在新链表数组的散列位置，这样就减少了每个链表的长度，增加查找效率
>
>

6. java中有没有统一的父类 ？

>在Java中，所有的基类都有一个默认的父类，那就是**Object类**

7. 接口与抽象类的区别？

>接口：
>
>抽象类：不能实例化 ，可以继承，但被继承后子类必须重写继承的方法，除非子类也是抽象类
>
>区别:
>
>接口被类实现，抽象类被类继承。
>
>接口只能做方法的声明，抽象类可以做方法声明，也可以做方法实现。
>
>接口只能定义公共的静态常量，抽象类定义普通变量。
>
>![image-20200503183414875](C:\Users\bear\AppData\Roaming\Typora\typora-user-images\image-20200503183414875.png)
>
>接口主要用来抽象功能，抽象类主要用来抽象类别。
>
>![image-20200503183243447](C:\Users\bear\AppData\Roaming\Typora\typora-user-images\image-20200503183243447.png)



8. Interger和int区别？

> interger是int的包装类 ，int是java的基本数据类型
>
> Interger变量必须实例化后才能使用
>
> int直接存储数据值，Interger是对象的引用
>
> Interger默认值是null,int 默认值0

9. 反射是什么？

反射机制是指在运行状态中，对于任何一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能调用它的任意方法和属性。动态获取信息，动态调用对象方法。比如bena的注入就是通过反射实现的。

10. 依赖注入（DI） 控制反转（IOC）

IOC：一种设计思想。











