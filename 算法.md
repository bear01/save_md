# 算法

##### 时间复杂度

一个算法执行所耗费的时间

##### 空间复杂度

运行完一个程序所需内存的大小

##### 排序

内排序：所有排序操作都在内存中完成

外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行

### 排序算法：

> **冒泡排序**

![这里写图片描述](http://img.blog.csdn.net/20160916160748389)

```java
//冒泡排序
public class bubbleSort {
	public static int[] Sort(int[] arr){
		int i,j;
		for(i=0;i<arr.length;i++){
			for(j=0;j<arr.length-1-i;j++){
				if(arr[j]>arr[j+1]){
					int max=arr[j];
					arr[j]=arr[j+1];
					arr[j+1]=max;
				}
			}
		}	
		return arr;
	}
	public static void main(String[] args) {
		int[] arr ={3,44,38,5,47,15,36,26,27,2,46,4,19,50,48};
		Sort(arr);
		for(int i=0;i<arr.length;i++){
			System.out.print(arr[i]+" "); // 2 3 4 5 15 19 26 27 36 38 44 46 47 48 50 
		}
	}

}
```




> **选择排序**

![这里写图片描述](http://img.blog.csdn.net/20160916164754013)

```java
//选择排序
public class selectionSort {
	private static void Sort(int[] arr,int n) {
		int i,j;
		int minIndex,temp;
		for(i=0;i<n-1;i++){
			minIndex=i;
			for(j=i+1;j<n;j++){
				if(arr[j]<arr[minIndex]){
					minIndex=j;
				}
			}
			temp=arr[i];
			arr[i]=arr[minIndex];
			arr[minIndex]=temp;
		}
	}
	public static void main(String[] args) {
		int[] arr ={3,44,38,5,47,15,36,26,27,2,46,4,19,50,48};
		int n=arr.length;
		Sort(arr,n);
		for(int i=0;i<n;i++){
			System.out.print(arr[i]+" ");//2 3 4 5 15 19 26 27 36 38 44 46 47 48 50 
		}

	}
}
```



> **插入排序**

![这里写图片描述](http://img.blog.csdn.net/20160916173802597)

```java
// 插入排序
public class insertionSort {
	public static int[] Sort(int[] arr,int n){
		// 第i号元素与前面的元素进行计较，找到比arr[i]小的位置，插到后面。
		for(int i=1;i<n;i++){
			int key=arr[i];
			int j=i-1;
			for(;j>=0&&arr[j]>key;j--){
				arr[j+1]=arr[j];
			}
			arr[j+1]=key;
			
			
		}
		return arr;
	}
	public static void main(String[] args) {
		int[] arr ={3,44,38,5,47,15,36,26,27,2,46,4,19,50,48};
		int n=arr.length;
		Sort(arr,n);
		for(int i=0;i<n;i++){
			System.out.print(arr[i]+" ");//2 3 4 5 15 19 26 27 36 38 44 46 47 48 50 
		}

	}

}

```



> **希尔排序**

![这里写图片描述](http://img.blog.csdn.net/20160916235203417)

```javascript
function shellSort(arr) {
    var len = arr.length,
        temp,
        gap = 1;
    console.time('希尔排序耗时:');
    while(gap < len/5) {          //动态定义间隔序列
        gap =gap*5+1;
    }
    for (gap; gap > 0; gap = Math.floor(gap/5)) {
        for (var i = gap; i < len; i++) {
            temp = arr[i];
            for (var j = i-gap; j >= 0 && arr[j] > temp; j-=gap) {
                arr[j+gap] = arr[j];
            }
            arr[j+gap] = temp;
        }
    }
    console.timeEnd('希尔排序耗时:');
    return arr;
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(shellSort(arr));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
```



> **归并排序**

![这里写图片描述](http://img.blog.csdn.net/20160917001326254)

```javascript
function mergeSort(arr) {  //采用自上而下的递归方法
    var len = arr.length;
    if(len < 2) {
        return arr;
    }
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}

function merge(left, right)
{
    var result = [];
    console.time('归并排序耗时');
    while (left.length && right.length) {
        if (left[0] <= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }

    while (left.length)
        result.push(left.shift());

    while (right.length)
        result.push(right.shift());
    console.timeEnd('归并排序耗时');
    return result;
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(mergeSort(arr));
```



> **快速排序**

![快速排序](http://img.blog.csdn.net/20160917003004906)

```javascript
function quickSort(array, left, right) {
    console.time('1.快速排序耗时');
    if (Object.prototype.toString.call(array).slice(8, -1) === 'Array' && typeof left === 'number' && typeof right === 'number') {
        if (left < right) {
            var x = array[right], i = left - 1, temp;
            for (var j = left; j <= right; j++) {
                if (array[j] <= x) {
                    i++;
                    temp = array[i];
                    array[i] = array[j];
                    array[j] = temp;
                }
            }
            quickSort(array, left, i - 1);
            quickSort(array, i + 1, right);
        }
        console.timeEnd('1.快速排序耗时');
        return array;
    } else {
        return 'array is not an Array or left or right is not a number!';
    }
}
```



> **堆排序**

![这里写图片描述](http://img.blog.csdn.net/20160917105502853)

```javascript
/*方法说明：堆排序
@param  array 待排序数组*/
function heapSort(array) {
    console.time('堆排序耗时');
    if (Object.prototype.toString.call(array).slice(8, -1) === 'Array') {
        //建堆
        var heapSize = array.length, temp;
        for (var i = Math.floor(heapSize / 2) - 1; i >= 0; i--) {
            heapify(array, i, heapSize);
        }

        //堆排序
        for (var j = heapSize - 1; j >= 1; j--) {
            temp = array[0];
            array[0] = array[j];
            array[j] = temp;
            heapify(array, 0, --heapSize);
        }
        console.timeEnd('堆排序耗时');
        return array;
    } else {
        return 'array is not an Array!';
    }
}
/*方法说明：维护堆的性质
@param  arr 数组
@param  x   数组下标
@param  len 堆大小*/
function heapify(arr, x, len) {
    if (Object.prototype.toString.call(arr).slice(8, -1) === 'Array' && typeof x === 'number') {
        var l = 2 * x + 1, r = 2 * x + 2, largest = x, temp;
        if (l < len && arr[l] > arr[largest]) {
            largest = l;
        }
        if (r < len && arr[r] > arr[largest]) {
            largest = r;
        }
        if (largest != x) {
            temp = arr[x];
            arr[x] = arr[largest];
            arr[largest] = temp;
            heapify(arr, largest, len);
        }
    } else {
        return 'arr is not an Array or x is not a number!';
    }
}
var arr=[91,60,96,13,35,65,46,65,10,30,20,31,77,81,22];
console.log(heapSort(arr));//[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96]
```



> **计数排序**

![这里写图片描述](C:\Users\bear\Desktop\20160917110641479)

```javascript
function countingSort(array) {
    var len = array.length,
        B = [],
        C = [],
        min = max = array[0];
    console.time('计数排序耗时');
    for (var i = 0; i < len; i++) {
        min = min <= array[i] ? min : array[i];
        max = max >= array[i] ? max : array[i];
        C[array[i]] = C[array[i]] ? C[array[i]] + 1 : 1;
    }
    for (var j = min; j < max; j++) {
        C[j + 1] = (C[j + 1] || 0) + (C[j] || 0);
    }
    for (var k = len - 1; k >= 0; k--) {
        B[C[array[k]] - 1] = array[k];
        C[array[k]]--;
    }
    console.timeEnd('计数排序耗时');
    return B;
}
var arr = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];
console.log(countingSort(arr)); //[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9]
```



> **桶排序**

![这里写图片描述](http://img.blog.csdn.net/20160917111945979)

```javascript
/*方法说明：桶排序
@param  array 数组
@param  num   桶的数量*/
function bucketSort(array, num) {
    if (array.length <= 1) {
        return array;
    }
    var len = array.length, buckets = [], result = [], min = max = array[0], regex = '/^[1-9]+[0-9]*$/', space, n = 0;
    num = num || ((num > 1 && regex.test(num)) ? num : 10);
    console.time('桶排序耗时');
    for (var i = 1; i < len; i++) {
        min = min <= array[i] ? min : array[i];
        max = max >= array[i] ? max : array[i];
    }
    space = (max - min + 1) / num;
    for (var j = 0; j < len; j++) {
        var index = Math.floor((array[j] - min) / space);
        if (buckets[index]) {   //  非空桶，插入排序
            var k = buckets[index].length - 1;
            while (k >= 0 && buckets[index][k] > array[j]) {
                buckets[index][k + 1] = buckets[index][k];
                k--;
            }
            buckets[index][k + 1] = array[j];
        } else {    //空桶，初始化
            buckets[index] = [];
            buckets[index].push(array[j]);
        }
    }
    while (n < num) {
        result = result.concat(buckets[n]);
        n++;
    }
    console.timeEnd('桶排序耗时');
    return result;
}
var arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
console.log(bucketSort(arr,4));//[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
```



> **基数排序**

![这里写图片描述](http://img.blog.csdn.net/20160917123313659)

```javascript
/**
 * 基数排序适用于：
 *  (1)数据范围较小，建议在小于1000
 *  (2)每个数值都要大于等于0
 * @author xiazdong
 * @param  arr 待排序数组
 * @param  maxDigit 最大位数
 */
//LSD Radix Sort

function radixSort(arr, maxDigit) {
    var mod = 10;
    var dev = 1;
    var counter = [];
    console.time('基数排序耗时');
    for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {
        for(var j = 0; j < arr.length; j++) {
            var bucket = parseInt((arr[j] % mod) / dev);
            if(counter[bucket]== null) {
                counter[bucket] = [];
            }
            counter[bucket].push(arr[j]);
        }
        var pos = 0;
        for(var j = 0; j < counter.length; j++) {
            var value = null;
            if(counter[j]!=null) {
                while ((value = counter[j].shift()) != null) {
                      arr[pos++] = value;
                }
          }
        }
    }
    console.timeEnd('基数排序耗时');
    return arr;
}
var arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];
console.log(radixSort(arr,2)); //[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]
```









**排序算法复杂度对比**

![这里写图片描述](http://img.blog.csdn.net/20160916153212716)

​				n: 数据规模， k:“桶”的个数， In-place: 占用常数内存， Out-place: 占用额外内存

**排序分类**

![这里写图片描述](http://img.blog.csdn.net/20160916154036887)



#### 经典算法

1. **穷举法**

   简单粗暴，基本什么问题都能搞定。

2. **贪心算法**

   简单，能获取局部最优解。

3. **动态规划**

   动态规划适合当最优化问题具有重复子问题和最优子结构的时候，提供了一个memory来缓存重复子问题的结果，避免了递归的过程中的大量的重复计算。

4. **分治算法**（递归的典型应用）

   分治算法的逻辑更简单了，就是一个词，分而治之。分治算法就是把一个大的问题分为若干个子问题，然后在子问题继续向下分，一直到base cases，通过base cases的解决，一步步向上，最终解决最初的大问题。

5. **回溯算法**（深度优先策略的典型应用）

   回溯算法就是沿着一条路向下走，如果此路不同了，则回溯到上一个
   分岔路，在选一条路走，一直这样递归下去，直到遍历万所有的路径

6. **分支限界算法**（广度优先的经典应用）

   回溯法一般来说是遍历整个解空间，获取问题的所有解，而分支限界法则是获取一个解（一般来说要获取最优解）